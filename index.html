<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>幾何探究學習工具</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; display: flex; flex-direction: column; align-items: center; background: #f4f7f6; margin: 0; padding: 20px; }
        .controls { background: white; padding: 15px; border-radius: 12px; margin-bottom: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; }
        #canvas-container { 
            width: 90vw; max-width: 600px; aspect-ratio: 1 / 1; position: relative; background: white; border: 2px solid #ddd;
            background-image: linear-gradient(#eee 1px, transparent 1px), linear-gradient(90deg, #eee 1px, transparent 1px);
        }
        canvas { display: block; cursor: crosshair; }
        #infoPanel { margin-top: 20px; padding: 20px; background: #e8f4fd; border-left: 6px solid #2196f3; width: 90%; max-width: 600px; border-radius: 4px; }
    </style>
</head>
<body>

<div class="controls">
    <select id="gridSize">
        <option value="5">5x5</option>
        <option value="9">9x9</option>
        <option value="16">16x16</option>
    </select>
    <input type="color" id="lineColor" value="#2196f3">
    <button onclick="undoLastLine()">復原</button>
    <button onclick="calculateShape()">計算面積與分類</button>
    <button onclick="clearCanvas()">清空</button>
</div>

<div id="canvas-container">
    <canvas id="gridCanvas"></canvas>
</div>

<div id="infoPanel">
    點擊網格交叉點開始連線，閉合圖形後點選「計算面積與分類」。
</div>

<script>
    const canvas = document.getElementById('gridCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('canvas-container');
    let gridSize = 5, lines = [], startPoint = null, mousePos = {x:0, y:0};

    function init() {
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        const cellSize = canvas.width / (gridSize - 1);
        container.style.backgroundSize = `${cellSize}px ${cellSize}px`;
        draw();
    }

    function getPoints() {
        const pts = [];
        const cellSize = canvas.width / (gridSize - 1);
        for(let i=0; i<gridSize; i++) {
            for(let j=0; j<gridSize; j++) {
                pts.push({x: j * cellSize, y: i * cellSize});
            }
        }
        return pts;
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const pts = getPoints();
        pts.forEach(p => { ctx.fillStyle="#aaa"; ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill(); });
        
        lines.forEach(line => {
            ctx.beginPath(); ctx.moveTo(line.start.x, line.start.y); ctx.lineTo(line.end.x, line.end.y);
            ctx.strokeStyle = line.color; ctx.lineWidth = 4; ctx.stroke();
        });

        if(startPoint) {
            ctx.beginPath(); ctx.moveTo(startPoint.x, startPoint.y); ctx.lineTo(mousePos.x, mousePos.y);
            ctx.setLineDash([5,5]); ctx.strokeStyle="red"; ctx.stroke(); ctx.setLineDash([]);
        }
    }

    // 視覺化填充：自動尋找連接路徑進行填色
    function fillShape() {
        if(lines.length < 3) return;
        ctx.fillStyle = "rgba(33, 150, 243, 0.2)";
        ctx.beginPath();
        
        // 排序路徑邏輯：確保路徑是連續的
        let currentPoint = lines[0].start;
        ctx.moveTo(currentPoint.x, currentPoint.y);
        
        // 這裡做簡單的路徑追蹤
        lines.forEach(l => {
            // 如果這條線的起點不是目前的終點，則先移過去
            ctx.lineTo(l.end.x, l.end.y);
        });
        
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    }

    function calculateShape() {
        if(lines.length < 3) {
            document.getElementById('infoPanel').innerHTML = "圖形尚未閉合，請繼續繪製！";
            return;
        }
        
        // 執行視覺填色
        draw(); // 先重繪清空之前的痕跡
        fillShape();
        
        let report = "<strong>圖形分析：</strong><br>";
        if(lines.length === 3) {
            const getDistSq = (l) => Math.pow(l.start.x - l.end.x, 2) + Math.pow(l.start.y - l.end.y, 2);
            let sides = lines.map(l => getDistSq(l)).sort((a, b) => a - b);
            let [a2, b2, c2] = sides;
            const eps = 100; // 允許網格坐標微小誤差
            let angle = (Math.abs(a2 + b2 - c2) < eps) ? "直角" : (a2 + b2 < c2) ? "鈍角" : "銳角";
            let type = (Math.abs(a2-b2)<eps && Math.abs(b2-c2)<eps) ? "正三角形" : (Math.abs(a2-b2)<eps || Math.abs(b2-c2)<eps) ? "等腰三角形" : "不等邊三角形";
            report += `這是個 <strong>${type}</strong> 且為 <strong>${angle}三角形</strong>。`;
        } else {
            report += `這是一個邊數為 ${lines.length} 的多邊形。`;
        }
        report += `<p>面積已填色，您可以數數看內部佔了多少格子！</p>`;
        document.getElementById('infoPanel').innerHTML = report;
    }

    canvas.addEventListener('click', (e) => {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left, my = e.clientY - rect.top;
        const pts = getPoints();
        const closest = pts.reduce((prev, curr) => Math.hypot(curr.x-mx, curr.y-my) < Math.hypot(prev.x-mx, prev.y-my) ? curr : prev);
        
        if(startPoint) {
            lines.push({start: startPoint, end: closest, color: document.getElementById('lineColor').value});
            startPoint = null;
        } else { startPoint = closest; }
        draw();
    });

    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        mousePos = {x: e.clientX - rect.left, y: e.clientY - rect.top};
        draw();
    });

    function undoLastLine() { lines.pop(); draw(); }
    function clearCanvas() { lines = []; startPoint = null; draw(); document.getElementById('infoPanel').innerHTML = "已清空，請重新繪製。"; }
    document.getElementById('gridSize').addEventListener('change', (e) => { gridSize = parseInt(e.target.value); init(); });
    window.addEventListener('resize', init);
    init();
</script>
</body>
</html>
